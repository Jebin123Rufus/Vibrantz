import express from 'express';
import mongoose from 'mongoose';
import cors from 'cors';
import dotenv from 'dotenv';
import jwt from 'jsonwebtoken';
import Groq from 'groq-sdk';
import { OAuth2Client } from 'google-auth-library';
import User from './models/User.js';
import Project from './models/Project.js';
import OTP from './models/OTP.js';
import nodemailer from 'nodemailer';
import { randomInt } from 'crypto';

dotenv.config({ path: './.env' });

const app = express();
app.use(cors());
app.use(express.json());

// Security Headers for Google OAuth
app.use((req, res, next) => {
  res.setHeader('Cross-Origin-Opener-Policy', 'same-origin-allow-popups');
  next();
});

// Nodemailer setup
const transporter = nodemailer.createTransport({
  service: process.env.EMAIL_SERVICE || 'gmail',
  auth: {
    user: process.env.EMAIL_USER,
    pass: process.env.EMAIL_PASS,
  },
});

const sendOTPEmail = async (email, otp) => {
  const mailOptions = {
    from: `"Vibrantz AI" <${process.env.EMAIL_USER}>`,
    to: email,
    subject: 'Your Verification Code',
    text: `Your OTP for Vibrantz AI is: ${otp}. It expires in 10 minutes.`,
    html: `
      <div style="font-family: 'Courier New', Courier, monospace; background-color: #0a0a0a; color: #ffffff; padding: 40px; border-radius: 12px; border: 1px solid #333;">
        <h2 style="color: #00ff88; border-bottom: 2px solid #00ff88; padding-bottom: 10px;">VIBRANTZ AI</h2>
        <p style="font-size: 16px;">System verification required.</p>
        <div style="background-color: #1a1a1a; padding: 20px; border-radius: 8px; text-align: center; margin: 30px 0;">
          <span style="font-size: 32px; letter-spacing: 10px; font-weight: bold; color: #00ff88;">${otp}</span>
        </div>
        <p style="color: #888; font-size: 14px;">This code expires in 10 minutes. If you did not request this, please ignore this email.</p>
        <div style="margin-top: 40px; font-size: 12px; color: #444;">
          AUTOGENERATED_SYSTEM_MAIL_ARCHITECT_PROTOCOL_V1
        </div>
      </div>
    `,
  };

  try {
    await transporter.sendMail(mailOptions);
  } catch (err) {
    console.error('Email sending failed:', err);
    throw new Error('Failed to send verification email');
  }
};

// Request Logger
app.use((req, res, next) => {
  console.log(`${new Date().toISOString()} - ${req.method} ${req.url}`);
  next();
});

const groq = new Groq({
  apiKey: process.env.VITE_GROQ_API_KEY,
});

const client = new OAuth2Client(process.env.VITE_GOOGLE_CLIENT_ID);

mongoose.connect(process.env.MONGODB_URI)
  .then(() => console.log('Connected to MongoDB'))
  .catch(err => console.error('MongoDB connection error:', err));

app.get('/api/health', (req, res) => res.json({ status: 'ok' }));

// Middleware to verify JWT
const authenticate = (req, res, next) => {
  const token = req.headers.authorization?.split(' ')[1];
  if (!token) return res.status(401).json({ error: 'Unauthorized' });

  try {
    const decoded = jwt.verify(token, process.env.JWT_SECRET);
    req.userId = decoded.userId;
    next();
  } catch (err) {
    res.status(401).json({ error: 'Invalid token' });
  }
};

// Auth Routes
app.post('/api/auth/send-otp', async (req, res) => {
  try {
    const { email, type } = req.body;
    if (!email) throw new Error('Email is required');

    if (type === 'register') {
      const existingUser = await User.findOne({ email });
      if (existingUser) throw new Error('User already exists');
    } else if (type === 'forgot_password') {
      const existingUser = await User.findOne({ email });
      if (!existingUser) throw new Error('User not found');
    }

    const otp = randomInt(100000, 999999).toString();
    await OTP.deleteOne({ email, type });
    await new OTP({ email, otp, type }).save();

    await sendOTPEmail(email, otp);
    res.json({ message: 'OTP sent successfully' });
  } catch (err) {
    console.error('OTP Error:', err);
    res.status(400).json({ error: err.message });
  }
});

app.post('/api/auth/register', async (req, res) => {
  try {
    const { email, password, otp } = req.body;
    if (!email || !password || !otp) throw new Error('All fields are required');

    const otpRecord = await OTP.findOne({ email, otp, type: 'register' });
    if (!otpRecord) throw new Error('Invalid or expired OTP');

    const user = new User({ email, password });
    await user.save();
    
    await OTP.deleteOne({ _id: otpRecord._id });

    const token = jwt.sign({ userId: user._id }, process.env.JWT_SECRET);
    res.json({ token, user: { id: user._id, email: user.email } });
  } catch (err) {
    console.error('Registration error:', err);
    res.status(400).json({ error: err.message });
  }
});

app.post('/api/auth/forgot-password-reset', async (req, res) => {
  try {
    const { email, otp, newPassword } = req.body;
    if (!email || !otp || !newPassword) throw new Error('All fields are required');

    const otpRecord = await OTP.findOne({ email, otp, type: 'forgot_password' });
    if (!otpRecord) throw new Error('Invalid or expired OTP');

    const user = await User.findOne({ email });
    if (!user) throw new Error('User not found');

    user.password = newPassword;
    await user.save();

    await OTP.deleteOne({ _id: otpRecord._id });

    res.json({ message: 'Password updated successfully' });
  } catch (err) {
    console.error('Reset error:', err);
    res.status(400).json({ error: err.message });
  }
});

app.post('/api/auth/login', async (req, res) => {
  try {
    const { email, password } = req.body;
    const user = await User.findOne({ email });
    if (!user || !(await user.comparePassword(password))) {
      return res.status(401).json({ error: 'Invalid credentials' });
    }
    const token = jwt.sign({ userId: user._id }, process.env.JWT_SECRET);
    res.json({ token, user: { id: user._id, email: user.email } });
  } catch (err) {
    console.error('Login error:', err);
    res.status(400).json({ error: err.message });
  }
});

app.post('/api/auth/google', async (req, res) => {
  try {
    const { credential } = req.body;
    const ticket = await client.verifyIdToken({
      idToken: credential,
      audience: process.env.VITE_GOOGLE_CLIENT_ID,
    });
    const { email, sub: googleId } = ticket.getPayload();

    let user = await User.findOne({ 
      $or: [{ googleId }, { email }] 
    });

    if (!user) {
      user = new User({ email, googleId });
      await user.save();
    } else if (!user.googleId) {
      user.googleId = googleId;
      await user.save();
    }

    const token = jwt.sign({ userId: user._id }, process.env.JWT_SECRET);
    res.json({ token, user: { id: user._id, email: user.email } });
  } catch (err) {
    console.error('Google Auth error:', err);
    res.status(400).json({ error: err.message });
  }
});

app.get('/api/auth/me', authenticate, async (req, res) => {
  const user = await User.findById(req.userId).select('-password');
  res.json({ user: { id: user._id, email: user.email } });
});

// Project Routes
app.get('/api/projects', authenticate, async (req, res) => {
  const projects = await Project.find({ userId: req.userId }).sort({ createdAt: -1 });
  res.json(projects.map(p => ({ ...p._doc, id: p._id })));
});

app.post('/api/projects', authenticate, async (req, res) => {
  try {
    const { title, description } = req.body;
    const project = new Project({
      userId: req.userId,
      title,
      description,
      status: 'generating'
    });
    await project.save();
    res.json({ ...project._doc, id: project._id });
  } catch (err) {
    res.status(400).json({ error: err.message });
  }
});

app.get('/api/projects/:id', authenticate, async (req, res) => {
  try {
    const project = await Project.findOne({ _id: req.params.id, userId: req.userId });
    if (!project) return res.status(404).json({ error: 'Project not found' });
    res.json({ ...project._doc, id: project._id });
  } catch (err) {
    res.status(400).json({ error: err.message });
  }
});

app.patch('/api/projects/:id', authenticate, async (req, res) => {
  try {
    const project = await Project.findOneAndUpdate(
      { _id: req.params.id, userId: req.userId },
      req.body,
      { new: true }
    );
    res.json({ ...project._doc, id: project._id });
  } catch (err) {
    res.status(400).json({ error: err.message });
  }
});

// AI Generation Route (Streaming)
app.post('/api/generate', authenticate, async (req, res) => {
  const { projectIdea, projectId } = req.body;

  res.setHeader('Content-Type', 'text/event-stream');
  res.setHeader('Cache-Control', 'no-cache');
  res.setHeader('Connection', 'keep-alive');

  const SYSTEM_PROMPT = `You are an advanced AI Project Architect. Your role is to convert a user's project idea into a complete, structured, execution-ready architecture blueprint.

You MUST output a valid JSON object with the following structure:
{
  "projectAnalysis": {
    "objective": "string",
    "type": "string",
    "complexity": "beginner|intermediate|advanced",
    "domains": ["string"]
  },
  "skillTree": [
    {
      "category": "string",
      "skills": [
        {
          "name": "string",
          "subskills": ["string"]
        }
      ]
    }
  ],
  "knowledgeChecklist": [
    {
      "module": "string",
      "items": ["string"]
    }
  ],
  "moduleArchitecture": [
    {
      "name": "string",
      "purpose": "string",
      "dependencies": ["string"],
      "inputs": ["string"],
      "outputs": ["string"]
    }
  ],
  "executionRoadmap": [
    {
      "step": number,
      "title": "string",
      "description": "string"
    }
  ],
  "taskBreakdown": [
    {
      "module": "string",
      "tasks": ["string"]
    }
  ]
}

Be specific, actionable, and dependency-aware. Use the tech stack: React + TypeScript + Vite + Tailwind CSS for frontend. For backend, suggest appropriate choices.
IMPORTANT: You MUST return ONLY the JSON object. Do not include markdown code blocks (like \`\`\`json), no preamble, and no postscript. 
Ensure the JSON is perfectly valid. Do NOT use raw newline characters inside string values; use "\\n" escape sequences if a newline is needed.
Do NOT include any text outside the JSON. Return ONLY valid JSON.`;

  try {
    const stream = await groq.chat.completions.create({
      messages: [
        { role: 'system', content: SYSTEM_PROMPT },
        { role: 'user', content: `Project Idea: ${projectIdea}\n\nGenerate a complete project architecture blueprint.` },
      ],
      model: 'llama-3.3-70b-versatile',
      stream: true,
    });

    let fullText = '';
    for await (const chunk of stream) {
      const content = chunk.choices[0]?.delta?.content || '';
      fullText += content;
      res.write(`data: ${JSON.stringify({ choices: [{ delta: { content } }] })}\n\n`);
    }

    res.write('data: [DONE]\n\n');
    res.end();
  } catch (err) {
    console.error('Generation error:', err);
    res.write(`data: ${JSON.stringify({ error: err.message })}\n\n`);
    res.end();
  }
});

const PORT = process.env.PORT || 5000;
app.listen(PORT, () => console.log(`Server running on port ${PORT}`));
